## Creational patterns 

	- Abstract Factory 
	- Builder 
	- Factory method 
	- Prototype 
	- Singleton 

Creational patterns are concerned with the process of object creation, the structural patterns 
are concerend with the composition of classes and objects, and the behavioral patterns are 
concerned with the interaction between objects and the delegation of resposibilities among them. 
They help provide flexibility in creating objects and hiding the details of object creation.

In this article we are going to explain creational design patterns using the example of an e-commerce 
applcation with examples in Go to create an efficient and scalable e-commerce site. 

## SIngleton pattern 

THe singleton pattern ensures that only a single instance of a class is created and provicdes a global point 
of access to that instance. This pattern is useful in situations where you need to ensure tha only one 
instance of a particular object exists at a time. 

In an e-commerce site, the Singleton pattern can be used to manage a global shopping cart object 
that is shared accross multiple pages. Here's an example implementation in Go 

```go 

type Item struct{
	Id int 
	ItemName string 
	Quantity int 
	Price float64
}

type ShoppingCart struct{
	intems []Item
}

var instance *ShoppingCart 

func GetShoppingCart() *ShoppingCart{
	if instance == nil{
		instance = &ShoppingCart{}
	}
	return instance 
}

```

In this example, the GetShoppingCart function returns a single instance of 
the ShoppingCart object. This ensures that all changes to the shopping cart 
are reflected accross the entire site, and prevents multiple copies of the 
shopping cart from being created. 

## Factory Pattern 

The factory pattern is used to create objects without exposing the creation logic to 
the client. This patterns is usefull in situations where you need to create complex 
objects that require a lot of setup. 

In an e-commerce site, the factory pattern can be used to create different types of 
products based on user input. Here's an example implementation in Go 

```go 

type Product interface{
	GetName() string 
}

type Book struct{}

func (b *Book) GetName() string{
	return "Book"
}

type DVD struct{} 

func (d *DVD) GetName() string{
	return "DVD"
}

type ProductFactory struct{}

func (f *ProductFactory) CreateProduct(productType string) Product{
	switch productType{
	case "Book":
		return &Book{} 
	case "DVD": 
		return &DVD
	default: 
		return nil 
	}
}
```

In this example, the ProductFactory creates different types of products (books and DVDs) 
based on user input. This allows the e-commerce site to easily add new product types 
without having to modify the client code. 

## Builder Pattern 

The builder pattern separates the construction of a complex object from its representation, 
allowing the same construction process to create different representations. THis pattern 
is usefull in situations where you need to create objects with multiple properties that can 
be set in different combinations. 

In an e-commerce site, the builder pattern can be used to create complex products objects with 
multiple properties (such as books with multiple authors and publishers). Here's an example in 
Go

```go 

type Book struct{
	Title string 
	Authors []string 
	Publisher string
}

type BookBuilder struct{
	book Book 
}

func (b *BookBuilder) SetTitle(title string) *BookBuilder{
	b.book.Title = title 
	return b
}

func (b *BookBuilder) SetAuthors(authors []string) *BookBuilder{
	b.book.Authors = authors 
	return b 
}

func (b *BookBuilder) SetPublisher(publisher string) *BookBuilder{
	b.book.Publisher = publisher 
	return b
}

func (b *BookBuilder) Build() *Book{
	return &b.book 
}

``` 

In this example, the BookBuilder allows the e-commerce site to create 
complex Book Objects with multiple authors and publishers. By separating 
the construction of the Book object from its representation, the 
e-commerce site can use the same construction process to create 
different representation of the Book object. 

## Conclusion 

In this article we've explored the commeon Creational Design patterns 
and provided examples of how they can be used in Go in the context of 
an e-commerce site. By using these patterns, you can create code that 
is modular, reusable and easier to maintain. Whether you're building 
an e-commerce site or any other type of software, understanding these 
patterns can help you create better software that is easier to maintain 
and scale.

