# Understanding Go Abstract Model 

The Go language was designed for dealing with the requirements of multicore 
processor computers as opposed to its counterparts like c and c++ which were 
designed in the the single core era. The C abstract model represents a 
single processor and a single block of memory.

It is a low level language for multiprocessor development

## Why Go?

Go was designed with concurrency in mind, as opposed to C where you have 
to use specialized libraries to write concurrent code, Go comes with 
support for concurrency out of the box

## Goroutines and Channels 

The fundamental concurrency primitive in Go is the Goroutine. 
This is a pun on coroutine. it's a method of flow control. 

A goroutine is like a function call that completes asyncronously. 
Conceptually, it runs in parallel, but the language does not 
define how it actually works in terms of real parallelism.

C does not provide any primitives for communicating between threads; 
they are implemented in libraries. C does not recognize threads.

Go in contrast is designed for concurrency. It uses a form of C.A.R Hoare's
Communicating Sequential Processes (CSP) formalism to facilitate 
communication between goroutines. 

CSP defines communication channels that events can be sent down. Go programs
can create channels and use them to communicate between threads

**A good rule of thumb for concurrent code is that the complexity of debugging
is proportional to the number of concurrent tasks multiplied by the number of 
possible ways in which they can interact**

* Go programs use garbage collection, making dangling pointers impossible, 
* and disallows pointer arithmetic, making most other categories of pointer-
* related errors impossible.

## The Go Type System

Go is a language that is statically and dynamically typed. It has tight coupling between 
components it also has loose coupling between components. Go allows you to select which of these features (static & dynamic typing, tight & loose coupling) is more appropriate for each use case.

The Go type system is visible via interfaces. Unlike Java interfaces or 
Objective-C protocols, they support duck typing and don't have to be 
explicitely adopted 

* duck typing: if it walks like a duck and quacks like a duct its a duck!

Go also support introspection on types. You can query any variable to find 
out whether it is an instance of the specified type, or whether it implements
a specified interface.

* On of the most useful features for the lazy programmer is the type inference
* that the Go compiler does. This allows you to avoid explicit type annotations
* on most variable declarations

## The Go Memory Model 

Go uses garbage collection (GC). Garbage collection means that you don't have
to think about when to deallocate memory like in C or C++. in Go you 
explicitely allocate values, but they are automatically reclaimed when they 
are no longer required. There is still a possibility to leak object when one 
accidentaly keeps referencing objects after using them. 

Garbage collection is a luxury in single threded programming ( a nice to have)
It becomes a neccessity when you start writing multithreaded code. If you are 
sharing pointers to an object between multiple threads, then working out
exactly when you can destroy the object is incredibly hard.

Like Java, and unlike C and C++. Go does not explicitely differentiate between
stack and heap allocations. Memory is just memory.

Go is designed to make garbage collection relatively easy to implement, although the existence of interior pointers makes it harder than a language
like Java.

* Because Go is designed for concurrency, the memory models defines exactly
* what to expect whent two go routines touch the same memory: 
* Go does not enforce any constraints on the order that memory accesses occur 
* with regard to each other. The compiler is free to reorder any memory accesses within a goroutine