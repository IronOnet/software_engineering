# Design Patterns

There are three categories of design patterns

  - Creational
  - Behavioral
  - Structural

## Design Principles

==> S.O.L.I.D

### Single Responsibility principle

A class should only do one thing, this also applies for packages

```go

type Reservation interface{
  GetReservationDate() string
  CalculateCancellationFee() float64
  Cancel()
  GetCustomerDetails() []Customer
  GetSellerDetails() Seller
}

```

### Open/Closed Principe (O)

A class should be opened for extension and closed for modification.
This esentially means that it should be possible to extend  or override class
behavior without having to modify code. Behavior change should be pluggable into
the class, either throurg overriding some methods or injecting some configuration.

==> One common place to use this principle is for algorithms or business logic. In our
travel website, let's say we have two requirements:

  - We should be able to bundle airline and hotel reservations into a Trip object
  - We should be able to calculate the cancellation fee for a trip.

Thus we can model Trips as a struct with a colleciton (repository) of reservations,
and for the cancellation, have each derived type for reservation compute the cancellation
fee as shown below:

```go

type Trip struct{
  reservations []Reservation
}

func (t *Trip) CaclculateCancellationFee() float64{
  total := 0.0

  for _, r := range(t.reservations){
    total += r.CalculateCancellationFee()
  }

  return total
}

func (t *Trip) AddReservation(r Reservation){
  t.reservations = append(t.reservations, r)
}

```

### Liskov Substitution Principle (L)

This is a slight variation of the Open/Closed principle,  
"Derived types must be substituable for their base types"

==> The crux of the principle is that derived classes must be usable thourh
the base class interface without the need for the client to know the specific
derived class.

### Interface Segregation Principle

As our code evolves, it is a common symptom for base classes to be a collect-all
for behavior. A base class should only deal with the common behavior and
have specific interfaces for other behavior

```go

type Reservation interface{
  GetReservationDate() string
  CalculateCancellationFee() float64
}

type HotelReservation interace{
  Reservation
  ChangeType()
}

type FlightReservation interface{
  Reservation
  AddExtraLuggageAllowance(pieces int)
}

type HotelReservationImpl struct{
  reservationDate string
}

func (r HotelReservationImpl) GetReservationDate() string{
  return r.reservationDate
}

func (r HotelReservationImpl) CalculateCancellationFee() float64{
  return 1.0 // float
}

type FlightReservationImpl struct{
  reservationDate string
  luggageAllowed int
}

func (r FlightReservationImpl) AddExtraLuggageAllowance(pieces int){
  r.luggageAllowed = pieces
}

func (r FlightReservationImpl) CalculateCancellationFee() float64{
  return 2.0
}

func (r FlightReservationImpl) GetReservationDate() string{
  return r.reservationDate
}

```

### Dependency inversion principle

The final principle is the Dependency Inversion Principle, which states the
following:

"Depend on abstractions, not on concretions".

This means that higher-level modules should depend only on interaces and not
on concrete implementations. In java huge frameworks such as Spring have come up
as dependency injection capabilities so that beans (object) can be injected
into the application at runtime. while the rest of the code just works with
interfaces of the beans (rather than the concrete implementation).

==> In Go, this principle boils down to two recommendations:

  - Every package should have interfaces that advertise functionality without the
  implementation specifics.
  - When a package needs a dependency, it should take that dependency as a parameter.

==> To illustrate the second point, let's
