# Microservices Decomposition strategies 

* This chapter covers: 
    -Understanding software architecture and why it's important 
    - Decomposing an application into services by applying the decomposition
    patterns, Decompose by business capability and Decompose by subdomain

    - Using the bounded context concept from domain driven design  to untangle
    data and make decomposition easier.


The key challenge with the microservice architecture is the functional decomposition of the application into services. 

The first and most important aspect of the architecturee is therefore, the 
definition of the services.

## What is the microservice architecture exactly?

Keyword: Functional decomposition 

### What is software architecture and why does it matters 

* The software architecture of a computing system is a set of structures needed to reason about the system, which comprise software eleements, relations among them and the properties of both.

In essence an architecture is a decomposition into parts (elements) and relationships (the relations) between thos parts. Decomposition is important 
for a couple of reasons. 

    - It facilitates the division of labor and knowledge. It enables multiple
    people (or multiple teams) with possibly specialized knowledge to work 
    productively together.

    - It defines how software elements interact.

* The 4+1 view model of software arhitecture 

The 4 + 1 model of software architecture defines four different views of a 
software architecture 

        - The Logical view: The software elements that are created by developers. In object oriented languages, these elements are classes
        and packages. the relations between them are the relationships between 
        classes and packages, including associations, inheritence and depends on.

        - The implementation View: The output of the build system. The view 
        consists of modules which represent packaged code and components which 
        are executable or deployable units consisting of one or more modules


        - Process View: The components at runtime. Each element is a process, 
        and the relations between processes represent interprocess communication 

        - The deployment view: How the processes are mapped to machines. The elements in this view consists of physical (physical or virtual) machines and the processes

In addition to theses views there is the scenarios, the +1 in the 4+1 model that animates the views. Each scenario describes how the various architectural 
components within a particular view collaborate to handle a request.

* The 4+1 model in summary 

    - The Logical view: 
    - The implementation view: 
    - The process view 
    - The deployment view

    And the scenarios that animate all these views.


#### Why architecture matters 

An application has two categories of requirements. the first category includes the functional requirements, 
which define what an application must do. They're usually in the form of uses cases and user stories. 

Architecture has very little to do with functional requirements. You can implement functional requirements with 
almost any architecture even the big ball of mud.


Architecture is important because it enables an application to satisfy the 
second category of requirements: its quality of service requirements. l)(Non-functional)

The quality of service requirements define the runtime qualities such as 
scalability and reliability. They also define development time qualities 
including maintainability, testability, and deployability. the architecture 
you choose for your application determines how well it meets these quality 
requirements.

#### Overview of architectural styles 

A particular architectural style provides a limited palette of elements (components) and relations (connectors) from which you can define a view 
of your application's architecture.

An application typically uses a combination of architectural styles.

* The monolithic architecture is an architectural style that structures the implementation view as a single (executable/deployable) compnoent 

* The microservice architecture structures an application as a set of loosely coupled services.

##### The layered architectural style 

A layered architectural style organizes software elements into layers. Each 
layer has a well-defined set of responsibilities. A layered architecture 
also constraints the dependencies between the layers. 

One can apply the layered architecture to any of the views discussed above. 

The popular three-tier architecture is the layered architecture applied to the 
logical view. it organizes the application's classes into the following tiers
or layers 

    - Presentation Layer: Contains code that implements the user interface 
    or external APIs 
    - Business logic layer: Contains the business logic *
    - Persistence layer: Implements the logic of interacting with the database

* The layered architecture is a great example of an architectural style but it has some significant drawbacks: 

        - Single presnetation layer: It doesn't represent the fact that an *
        application is likely to be invoked by more than just a single system

        - Single persistence layer: It doesn't represnet the fact that an application can interact with more than a single database

        - Defines the business logic layer as depending on the persistence layer: In theory, this dependency prevents you from testing the business logic without the database. 

The layered architecture tends to missrepresent the dependencies in a well designed application 


##### The Hexagonal architecture 

The Hexagonal architecture is an alternative style to the layered architecture. The hexagonal architecture organizes the logical view in a 
way that places the business logic at the center. 

Instead of the presentation layer, an application has one more inbound adapters
that handle requests from the outside by invoking the business logic.


The business logic has one or more ports. A port defines as set of operations 
and is how the business logic interacts with what's outside of it. 

In Java for example, a port is a Java interface. 
* There are two kinds of ports, inbound and outbound ports.  

        - Inbound port: an API exposed by the business logic wich enables it 
        to be invoked by external applications. An example of an inbound port 
        is a service interface, which defines a service's public methods.

        - Outbound port: an outbound port is how the business logic invokes 
        external systems. An example of an outbound port is a repository interface, which defines a collection of data access operations.


* Surrounding the business logic are adapters. As with ports, there are two types of adapters: inbound and outbound 
        
        - Inbound adapter: An inbound adapter handles requests from the outside world by invoking an inbound port. An example of an inbound
        adapter is a Spring MVC controller that implements either a set of REST endpoints or a set of web pages. Another example is a message broker client that subscribe to messages.

        - An Outbound adapter implements an outbound port and handles requests from the business logic by invoking an external application or service. An example of an outbound adapter is a data access object 
        (DAO) class the implements operations for accessing the database.


An important benefit of the hexagonal architecture is that it decouples the business logic from the presentation and data access logic in the adapters. 
The business logic doesn't depend on either presentation logic or data acess logic.

The layered and hexagonal architectures are both examples of architectural styles. Each defines the building blocks of an architecture and imposes constraints on the relationships between them.


##### The microservice architecture is also an architectural style 

The microservice architecture is also an architectural style as it structures 
the implementation view as a set of multiple components: executable or WAR files. the components are services, and the connectors are the communication 
protocols that enable those services to collaborate. Each service has its own logical view architecture, which is typically an hexagonal architecture.


* A key constraint imposed by the microservice architecture is that the services are loosely coupled. Consequently, there are restrictions on how 
    the services collaborate.

* What is a service? 

A service is a standalone, independently deployable software component that 
implement some useful functionality. 
A service has an API that provides its clients access to its functionality. there are two types of operations: commands and queries. 

The API consists of commands, queries and events. A command such as 
createOrder() performs actions and updates data. a query such as 
findOrderById(), retrieves data. a service also publishes events, such as 
OrderCreated, which are consumed by its clients. 

A service API encapsulates an internal implementation. Unlike a monolith, a developer can't write code that bypasses its API. as a result the micsorservice architecture enforces the application modularity.

Each service in a microservice architecture has its own architecture and potentially, technology stack. But a typical service has an hexagonal architecture. It's API implemented by adapters that interact with the service's business logic.

* What is loose coupling? 

An important characteristic of the microservice architecture is that all 
the services are loosely coupled. All interaction with a service happens
via its API, which encapsulates implementation details. 
This enables the implementation of the service to change without affecting its
clients

The requirements for services to be loosely coupled and to collaborate only 
via APIs prohibits services from communicating via a database.

* The role of shared libraries 

Developers often package functionality in a library so that it can 
be reused by multiple applications without duplicating code

**One should strive to use libraries only for functionality that dont change.**


* The size of a service is mostly unimportant

A much better goal is to define a well-designed service capable of being 
developed by a small team with minimal lead time and with minimal collaboration with other teams. In theory a team might only be responsible 
for a single service.


## Defining an application microservice architecture 

How should we define a microservice architecture?
As with any software development effort, the starting points are the written 
requirements, hopefully domain experts, and perhaps an existing application.

In this section we define a three step process for defining an application's architecture


* Step 1: Identify the system's operations

The starting point are the requirements such as user's stories, 
a system operation's represent an external request. 
The first step in defining an architecture is to distill the application's 
requrements into key requests. But instead of describing the requests in 
terms of specific IPC technologies such as REST or messaging, use a more 
abstract notion of system operation

A system operation is an abstraction of a request that the system must 
handle. It's either a command which updates data or a query which retrieves
data.

* Step 2: Determine the decomposition into services

    - Define services corresponding to business capabilities 
    - Organize services zround domain driven design subdomains


* Step 3: Determine each service's API

To do that, you assign each system operation identified in the first step 
to a service. A service might implement an operation entirely by itself


There are several obstacles to decomposition. The first is network latency. 
You might discover that a particular decomposition would be impractical due 
to many round trips between services. 

### Identifying the system's operations

The system's operation are identified using a two step process. the first step
is to create a high-level domain model. The second step is to define the system's operations, which are defined in terms of the domain model. 


The domain model is derived primarily from the nouns of the user's stories, 
and the system operations are derived mostly from the verbs.

You could also defined a domain model using a technique called event storming. 
The behaviour of each system operation is described in terms of its effect
on one or more domain objects and the relationships between them. A system 
operation can create, update, or delete domain objects, as well as create or 
destroy relationships between them.

#### Creating a high level domain model

The first step in the process of defining the system's operation is to sketch
a high level domain model for the application. This domain model is much simpler than what will be implemented

A domain model is created using standard techniques such as analyzing the 
nouns in the stories and scenarios and talking to the domain experts.

```DL 

    Given a consumer 
        And a restaurant 
        And a delivery address/time that can be served by that restaurant
        And an order total that meets the restaurant's order minimum 
    When the consumer places an order for the restaurant 
    Then the consumer's credit card is authorized 
        And an order is created in the PENDING_ACCEPTANCE state 
        And the order is associated with the consumer 
        And the order is associated with the restaurant

``` 

The nouns in this user scenario hint at the existence of various classes, 
including Consumer, Order, Restaurant and CreditCard

Similarly the Accept Order scenario can be expanded into a scenario such as 
this one: 

```DL 

    Given an Order that is in the PENDING_ACCEPTANCE state 
        and a courier that is available to deliver the order 
    When a restaurant accepts and order with a promise to prepare by 
    a particular time. 
    Then the state of the order is changed to ACCEPTED 
        And the Order's promiseByTime is updated to the promised time
        And the courier is assigned to deliver the order
```

The responsibilities of each class are as follows: (cfr book): 

    - Consumer: A consumer who places orders 
    - Order: An order placed by a consumer. It describes the order 
    and tracks its status 
    - OrderLineItem: A line item for an order 
    - DeliveryInfo: The time and place to deliver an order 
    - Restaurant: A restaurant prepares orders for delivery to consumers. 
    - MenuItem: An item on the restaurant's menu 
    - Courier: A courier who deliver orders to consumers. It tracks the availability of the courier and their current location 
    - Address: The address of a consumer or a Restaurant 
    - Location: the latitude and longitude of a courier


#### Defining system operations

Once you've defined a high level domain model, the next step is to 
identify the requests that the application must handle  

There are two types of system operations: 
    - Commands 
    - Queries

Ultimately these system operations will correspond to REST, RPC, or messaging
endpoints. 
A good starting point for identifying system commands is to analyze the verbs
in the users stories and scenarios. Consider