# Microservices Decomposition strategies 

* This chapter covers: 
    -Understanding software architecture and why it's important 
    - Decomposing an application into services by applying the decomposition
    patterns, Decompose by business capability and Decompose by subdomain

    - Using the bounded context concept from domain driven design  to untangle
    data and make decomposition easier.


The key challenge with the microservice architecture is the functional decomposition of the application into services. 

The first and most important aspect of the architecturee is therefore, the 
definition of the services.

## What is the microservice architecture exactly?

Keyword: Functional decomposition 

### What is software architecture and why does it matters 

* The software architecture of a computing system is a set of structures needed to reason about the system, which comprise software eleements, relations among them and the properties of both.

In essence an architecture is a decomposition into parts (elements) and relationships (the relations) between thos parts. Decomposition is important 
for a couple of reasons. 

    - It facilitates the division of labor and knowledge. It enables multiple
    people (or multiple teams) with possibly specialized knowledge to work 
    productively together.

    - It defines how software elements interact.

* The 4+1 view model of software arhitecture 

The 4 + 1 model of software architecture defines four different views of a 
software architecture 

        - The Logical view: The software elements that are created by developers. In object oriented languages, these elements are classes
        and packages. the relations between them are the relationships between 
        classes and packages, including associations, inheritence and depends on.

        - The implementation View: The output of the build system. The view 
        consists of modules which represent packaged code and components which 
        are executable or deployable units consisting of one or more modules


        - Process View: The components at runtime. Each element is a process, 
        and the relations between processes represent interprocess communication 

        - The deployment view: How the processes are mapped to machines. The elements in this view consists of physical (physical or virtual) machines and the processes

In addition to theses views there is the scenarios, the +1 in the 4+1 model that animates the views. Each scenario describes how the various architectural 
components within a particular view collaborate to handle a request.

* The 4+1 model in summary 

    - The Logical view: 
    - The implementation view: 
    - The process view 
    - The deployment view

    And the scenarios that animate all these views.


#### Why architecture matters 

An application has two categories of requirements. the first category includes the functional requirements, 
which define what an application must do. They're usually in the form of uses cases and user stories. 

Architecture has very little to do with functional requirements. You can implement functional requirements with 
almost any architecture even the big ball of mud.


Architecture is important because it enables an application to satisfy the 
second category of requirements: its quality of service requirements. l)(Non-functional)

The quality of service requirements define the runtime qualities such as 
scalability and reliability. They also define development time qualities 
including maintainability, testability, and deployability. the architecture 
you choose for your application determines how well it meets these quality 
requirements.

#### Overview of architectural styles 

A particular architectural style provides a limited palette of elements (components) and relations (connectors) from which you can define a view 
of your application's architecture.

An application typically uses a combination of architectural styles.

* The monolithic architecture is an architectural style that structures the implementation view as a single (executable/deployable) compnoent 

* The microservice architecture structures an application as a set of loosely coupled services.

##### The layered architectural style 

A layered architectural style organizes software elements into layers. Each 
layer has a well-defined set of responsibilities. A layered architecture 
also constraints the dependencies between the layers. 

One can apply the layered architecture to any of the views discussed above. 

The popular three-tier architecture is the layered architecture applied to the 
logical view. it organizes the application's classes into the following tiers
or layers 

    - Presentation Layer: Contains code that implements the user interface 
    or external APIs 
    - Business logic layer: Contains the business logic *
    - Persistence layer: Implements the logic of interacting with the database

* The layered architecture is a great example of an architectural style but it has some significant drawbacks: 

        - Single presnetation layer: It doesn't represent the fact that an *
        application is likely to be invoked by more than just a single system

        - Single persistence layer: It doesn't represnet the fact that an application can interact with more than a single database

        - Defines the business logic layer as depending on the persistence layer: In theory, this dependency prevents you from testing the business logic without the database. 

The layered architecture tends to missrepresent the dependencies in a well designed application 


##### The Hexagonal architecture 

The Hexagonal architecture is an alternative style to the layered architecture. The hexagonal architecture organizes the logical view in a 
way that places the business logic at the center. 

Instead of the presentation layer, an application has one more inbound adapters
that handle requests from the outside by invoking the business logic.


The business logic has one or more ports. A port defines as set of operations 
and is how the business logic interacts with what's outside of it. 

In Java for example, a port is a Java interface. 
* There are two kinds of ports, inbound and outbound ports.  

        - Inbound port: an API exposed by the business logic wich enables it 
        to be invoked by external applications. An example of an inbound port 
        is a service interface, which defines a service's public methods.

        - Outbound port: an outbound port is how the business logic invokes 
        external systems. An example of an outbound port is a repository interface, which defines a collection of data access operations.


* Surrounding the business logic are adapters. As with ports, there are two types of adapters: inbound and outbound 
        
        - Inbound adapter: An inbound adapter handles requests from the outside world by invoking an inbound port. An example of an inbound
        adapter is a Spring MVC controller that implements either a set of REST endpoints or a set of web pages. Another example is a message broker client that subscribe to messages.

        - An Outbound adapter implements an outbound port and handles requests from the business logic by invoking an external application or service. An example of an outbound adapter is a data access object 
        (DAO) class the implements operations for accessing the database.


An important benefit of the hexagonal architecture is that it decouples the business logic from the presentation and data access logic in the adapters. 
The business logic doesn't depend on either presentation logic or data acess logic.

The layered and hexagonal architectures are both examples of architectural styles. Each defines the building blocks of an architecture and imposes constraints on the relationships between them.


##### The microservice architecture is also an architectural style 

The microservice architecture is also an architectural style as it structures 
the implementation view as a set of multiple components: executable or WAR files. the components are services, and the connectors are the communication 
protocols that enable those services to collaborate. Each service has its own logical view architecture, which is typically an hexagonal architecture.


* A key constraint imposed by the microservice architecture is that the services are loosely coupled. Consequently, there are restrictions on how 
    the services collaborate.

* What is a service? 

A service is a standalone, independently deployable software component that 
implement some useful functionality. 
A service has an API that provides its clients access to its functionality. there are two types of operations: commands and queries. 

The API consists of commands, queries and events. A command such as 
createOrder() performs actions and updates data. a query such as 
findOrderById(), retrieves data. a service also publishes events, such as 
OrderCreated, which are consumed by its clients. 

A service API encapsulates an internal implementation. Unlike a monolith, a developer can't write code that bypasses its API. as a result the micsorservice architecture enforces the application modularity.

Each service in a microservice architecture has its own architecture and potentially, technology stack. But a typical service has an hexagonal architecture. It's API implemented by adapters that interact with the service's business logic.

* What is loose coupling? 

An important characteristic of the microservice architecture is that all 
the services are loosely coupled. All interaction with a service happens
via its API, which encapsulates implementation details. 
This enables the implementation of the service to change without affecting its
clients

The requirements for services to be loosely coupled and to collaborate only 
via APIs prohibits services from communicating via a database.

* The role of shared libraries 

Developers often package functionality in a library so that it can 
be reused by multiple applications without duplicating code

**One should strive to use libraries only for functionality that dont change.**


* The size of a service is mostly unimportant

A much better goal is to define a well-designed service capable of being 
developed by a small team with minimal lead time and with minimal collaboration with other teams. In theory a team might only be responsible 
for a single service.


