# Interprocess Communication in A microservice Architecture 

Whithin a monolithic application modules invoke one another via language 
level method or function calls. microservices interact with each other 
using RPC since they are implemented as a set of separate services.

There's no shortage of RPC mechanisms to choose from, the most common IPC 
mechanism used for microservice architectures is REST.

## Overview of IPC in a microservice architecture 

Services can use either syncrhonous request/response based communication mechanisms such as HTTP based REST or gRPC. Alternatively they can use 
asynchronous, message-based communication mechanisms such as AMPQ or STOMP. 

There are also a variety of different message formats such as JSON or XML.
Alternatively, they could use a more efficient binary format such as Avro 
or Protocl Buffers.

### Interaction styles 

The choice of the interaction style impacts the availability of your application. 
There are a variety of client-service interaction styles, they can be 
categorized in two dimensions. 

* The first dimension is whether the interaction is one-to-one or many-to-many: 
    - One-to-One: Each client request is processed by exactly one service 
    - One-to-Many: Each request is processed by multiple services.

* The second dimension is whether the interaction is synchronous or asyncrhonous: 
    - Syncronous: The client expects a timely response from the service and 
    might even block while it waits. 
    - Asyncrhonous: The client doesn't block, and the response, if any isn't 
    necesserily sent immediately


The following are the different types of one-to-one interactions:

    - Request/response: A service client makes a request to a service and 
    waits for a response. 

    - Asynchronous request/response: A service client sends a request to a service, which replies asyncrhonously.

    - One way notifications: A service client sends a request to a service, 
    but no reply is expected or sent


The following are the different types of one-to-many interactions: 

    - Publish subscribe: A client publishes a notification message, 
    which is consumed by zero or more interested services. 

    - Publish/async responses, A client publishes a request message and then 
    waits for a certain amount of time for responses from interested services

### Defining APIs in a MS architecture 

A service API is a contract between the service and its clients. it consists
of operations, which clients can invoke, and events which are published by 
the service. An operation has a name

Regardless of which IPC mechanism you choose, it's important to precisely
define a service's API using some kind of interface definition language (IDL)

First you write the interface definition. Then you review the interface 
definition with the client developers. Only after iterating on the API 
definition you then implement the service


* The nature of the API definition depends on which IPC mechanisms you're using. For example, if you're using messaging the API consists of message 
* channels, the message types and the message format. 

* If you're using HTTP the API consists of the URL, the HTTP verbs, and the 
* requests and response formats.


### Evolving APIs 

APIs inevitably change overtime as new features are added, existing features
are changed and perhaps old features are removed


* Use semantic versioning

The semantic versioning specification is a useful guide to versioning APIs. 
[Semver](https://semver.org) 
It's a set of rules that specify how version numbers are used and incremented
Semantic versioning

    - MAJOR: When you make an incompatible change to the API. 
    - MINOR: When you make backward compatible enhancements to the API
    - PATCH: When you make a backward compatible bug fix.


### Message Formats 

    There are two main categories of message formats: 
        - Text based : (JSON & XML)
        - Binary (Protobuf & Avro)


### Communicating using the synchronous Remote procedure invocation pattern

When using an RCP mechanism, a client sends a request to a service, and 
the service processes the request and sends back a response. 

in the RPI pattern the business logic in the client invokes a proxy interface, 
implemented by an RPI proxy adapter class. The RPI proxy makes a request 
to the service. The request is handled by an RPI server adapter class, which 
invokes the service's business logic via an interface. It then sends back a reply to the RPI proxy, which returns the result to the client's business logic.


#### Using REST

Rest uses (almost) HTTP verbs. a key concept in REST is that of a resource, which typically represents a single business object such as a Customer or 
product, or a collection of business objects.

REST uses HTTP verbs to manipulate resources, which are referenced using a
URL. For example a GET request returns the representation of a resource,  
which is often in the form of an XML or JSON object, other format such as 
binary can also be used. 

A POST request creates a new resource, a PUT request updates a resource.

##### The REST maturity model 

* Level 0: Clients of a level 0 service invoke the service by making 
HTTP POST requests to its sole URL endpoint. Each request specifies 
the action to perform, the target of the action, and any parameters. 

* Level 1: A level 1 service supports the idea of resources. To perform an 
action on a resource, a client makes a POST request that specifies the action 
to perform and any parameters.

* Level 2: A level 2 service use HTTP verbs to perform actions, GET to retrieve
POST to create, PUT to update. The request query parameters and body, if any 
specify action parameters. This enables services to use web infrastructure to 
such as caching for GET requests.

* Level 3: The design of a level 3 REST service is based on the terribly named HATEOAS (Hypertext As the Engine of Application State) principle. 
The basic idea is that the representation of a resource returned by a GET 
request contains links for performing actions on that resource

##### Specifying REST APIs

One must define an API using an interface definition language (IDL). 
The most popular REST IDL is the OPEN API specification (www.openapis.org), which evolved from the swagger open source project.