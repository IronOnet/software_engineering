# Chapter 5: Designing business logic in a microservice architecture


This chapter covers: 
    - Applying the business logic organization patterns:
    Transaction script and domain model pattern 

    - Designing business logic with the Domain-driven-design 
    (DDD) aggregate pattern 

    - Applying the domain event in a microservice architecture.


## Business logic organization patterns 

In a typical hexagonal service, the service is surrounded by inbound and 
outbound adapters. 

    - inbound adapters: handle requests from clients and invoke the business logic 
    - outbound adapters: invoked by the business logic, they invoke other 
    services and applications 

There are two main patterns for organizing business logic: 
    - The procedural transaction script pattern, and the object oriented
    Domain model pattern 

### Designing business logic with the transaction script pattern 

When you're developing a simple buisiness logic. In such a situation a better
approach is to write procedural code and use the Transaction script pattern.

* Pattern Transaction Script: Organize the business logic as a collection of procedural transactions scripts, one for each type of request.

This is what you would create if you were writing an application in C or 
other non OOP languages. this is not a good approach to implementing 
complexi buisiness logic 

### Desgining business logic usgin the domain model pattern 

The simplicity of the procedural approach can be quite seductive. 
You can write out code without having to carefully consider how to organize classes. 

Transactions scirpts have the same problems as monoliths as your business 
logic becomes complex the you codebase ends up being messy and unmanageable. 

Unless you're writting an extremely simple application you should resist the 
temptation to write transaction scripts. you should rather consider applying 
the domain model pattern and develop and object oriented design.

* Pattern, Domain Model: Organize the business logic as an object model consisting of classes that have state and behavior. 


In an object-oriented design, the business logic consists of an object model, 
a network of relatively small classes. these classes typically correspond
directly to concepts from the problem domain.

Using an object-oriented design has a number of benefits. First the design is 
easy to understand and maintain. Instead of consisting of one big class that does everything, it consists of a number of small classes that each have a 
small number of responsibilities. 

Second an object-oriented design is easier to test 

* The domain model pattern works well, but there are number of problems with 
* this approach, especially in a microservice architecture. 
* to address these problems we need a refinement of OOD, called DDD

### About domain driven design 

Domain driven design is a refinement of object oriented design, it's an approach for designing complex business logic. 

In the context of services when using domain driven design each service 
has its own domain model, which avoids the problems of a single, application
wide domain model. Subdomains and the associated concept of bounded contexts 
are two of the strategic DDD patterns. 

DDD also has some tactical patterns that are building blocks for domain models.
Each pattern is a role that a class plays in a domain model and defines 
the characteristics of a class. 

The building blocks that are widely adopted by developers include the 
following: 

    - Entity: An object has a persistent identity. Two entities whose attributes have the same values are still different objects.

    - Value Objects: An object that is a collection of values. Two value objects whoes attributes have the same values

    - Factory: An object or method that implements object creation logic 
    that's too complex to be done directly by a constructor. It can also 
    hide the concrete classes that are instantiated

    - Repository: An object that provides access to persistent entities
    and encapsulates the mechanism for accessing the database. 

    - Service: An object that implements business logic that does'nt belong
     in an entity or a value object. 

### Designing a domain Model using the aggregate pattern 

A traditional domain model is a web of interconnected classes. It doesn't
explicitely specify the boundaries of business objects. 

* The problem with fuzzy boundaries 

Imagine that we want to perform an operation such as load or delete on a 
an Order business object. What exactly does that mean? what is the 
scope of the operation? you would certainly load or delete the Order object. 
but in reality there's more to an Order than simply the Order object. 
There are also the LineItems, the payment information, and so on. 
this leaves the boundaries of a domain object to a developer's intuition. 

Besides conceptual fuzziness, the lack of explicit boundaries causes problems 
when updating a business object. A typical business object has invariants that
must be enforced at all times

* Aggregates have explicit boundaries 

* Pattern, Aggregate: Organize a domain model as a collection of aggregates, 
* each of which is a graph of objects that can be treated as a unit. 

Aggregates decompose a domain model into chunks, which are individualy easier
to understand. They also clarify the scope of operations such as load, update
and delete. 
These operations act on the entire aggregate rather than on parts of it. 
An aggregate is often loaded in its entirety from the database, thereby
avoiding any complications of lazy loading. Deleting an aggegate remove 
all of its objects from the database. 

* Aggregates are consistency boundaries 

Updating en entier aggregate rather than parts of it solves the consistency 
issues, such as the example described in the book (two customers scenario cfr
book)

* Identifying an aggregate is key

In DDD, a key part of designing a domain model is identifying aggregates, 
their boundaries, and their roots. The details of the aggregate's internal
structure is secondary.

#### Aggregates Rules 

DDD requires aggregates to obey a set of rules. These rules ensure that an 
aggregate is a self contained unit that can enforce it's invariants